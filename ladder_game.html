<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Ladder Game</title>
    <style>
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: block;
        }

        canvas {
            border: 0px solid black;
            background-color: black;
            /* display: block;
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100%;
            width: 100%; */
        }
    </style>
</head>

<!-- <body onload="startGame()"> -->

<body>
    <div id="canvas"></div>

    <!-- <h1>Ladder Game</h1> -->
    <script>
        window.onload = function () {
            const userIndexes = [];  // rail indexes of users after tracing
            const userInitials = [];
            const drawingDelay = 0;
            const ladderColor = "white";
            const ladderWidth = 2;
            const rungMaxNumber = 100;
            const railNumber = parseInt(prompt("Input the number of rails: ", 5));
            const prayer = Math.floor(Math.random() * railNumber); // rail index of prayer
            const traceColor = "magenta";
            const traceWidth = 3;

            let canvasWidth = window.innerWidth;
            let canvasHeight = window.innerHeight;
            let railHeight = 0.8 * canvasHeight;
            // let rungMaxNumber = parseInt(prompt("Input the maximum number of rungs per rail: ", 50));
            let rungWidth = canvasWidth / railNumber;
            let rungSpace = railHeight / (rungMaxNumber + 1);
            let rungStatus = Array.from(Array(railNumber - 1), () => new Array(rungMaxNumber));
            let gameCanvas = {
                canvas: document.createElement("canvas"),
                start: function () {
                    this.canvas.width = canvasWidth;
                    this.canvas.height = canvasHeight;
                    this.context = this.canvas.getContext("2d");
                    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                }
            }

            // function startGame() {
            gameCanvas.start();
            const ctx = gameCanvas.context;
            ctx.font = "25px Monospace";
            ctx.fillStyle = "yellow";
            ctx.lineWidth = ladderWidth;
            ctx.strokeStyle = ladderColor;
            ctx.textAlign = "center";
            const fontHeight = parseInt(ctx.font);

            // draw rails
            y = 0.1 * canvasHeight;
            for (let i = 0; i < railNumber; i++) {
                x = (i + 0.5) * rungWidth;
                userInitials[i] = prompt("Input a user initial: ", "AA");
                ctx.fillText(userInitials[i], x, y - 0.25 * fontHeight);
                // ctx.fillText((i+1).toString(), x, y - 0.25 * fontHeight);
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + railHeight);
                // setTimeout(() => ctx.lineTo(x, y + railHeight), i * drawingDelay);
                ctx.stroke();
            }
            x = (prayer + 0.5) * rungWidth;
            y = 0.9 * canvasHeight;
            ctx.fillStyle = "chartreuse"
            ctx.fillText("PRAYER", x, y + 0.9 * fontHeight);

            // draw random rungs
            for (let i = 0; i < railNumber - 1; i++) {
                x = (i + 0.5) * rungWidth;
                y = 0.1 * canvasHeight + rungSpace;
                for (let j = 0; j < rungMaxNumber; j++) {
                    if (Math.random() < 0.5) {
                        rungStatus[i][j] = 0;
                    } else {
                        if (i == 0 || (i > 0 && rungStatus[i - 1][j] == 0)) {
                            rungStatus[i][j] = 1;
                            ctx.beginPath();
                            ctx.moveTo(x, y + j * rungSpace);
                            ctx.lineTo(x + rungWidth, y + j * rungSpace);
                            ctx.stroke();
                        } else {
                            rungStatus[i][j] = 0;
                        }
                    }
                }
            }

            // trace down rails and rungs
            ctx.lineWidth = traceWidth;
            for (let i = 0; i < railNumber; i++) {
                // ctx.strokeStyle = traceColor;
                ctx.strokeStyle = rainbow(railNumber, i);
                railIdx = i;
                x = (i + 0.5) * rungWidth;
                y = 0.1 * canvasHeight;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + rungSpace);
                ctx.stroke();
                y += rungSpace;
                for (let j = 0; j < rungMaxNumber; j++) {
                    if (railIdx > 0 && rungStatus[railIdx - 1][j] == 1) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x - rungWidth, y);
                        ctx.stroke();
                        x -= rungWidth;
                        railIdx -= 1;
                    } else if (railIdx < railNumber - 1 && rungStatus[railIdx][j] == 1) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + rungWidth, y);
                        ctx.stroke();
                        x += rungWidth;
                        railIdx += 1;
                    }
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, y + rungSpace);
                    ctx.stroke();
                    y += rungSpace;
                }
                userIndexes[i] = railIdx;
            }

            function rainbow(numOfSteps, step) {
                // This function generates vibrant, "evenly spaced" colours (i.e. no clustering). This is ideal for creating easily distinguishable vibrant markers in Google Maps and other apps.
                // Adam Cole, 2011-Sept-14
                // HSV to RBG adapted from: http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
                var r, g, b;
                var h = step / numOfSteps;
                var i = ~~(h * 6);
                var f = h * 6 - i;
                var q = 1 - f;
                switch (i % 6) {
                    case 0: r = 1; g = f; b = 0; break;
                    case 1: r = q; g = 1; b = 0; break;
                    case 2: r = 0; g = 1; b = f; break;
                    case 3: r = 0; g = q; b = 1; break;
                    case 4: r = f; g = 0; b = 1; break;
                    case 5: r = 1; g = 0; b = q; break;
                }
                var c = "#" + ("00" + (~ ~(r * 255)).toString(16)).slice(-2) + ("00" + (~ ~(g * 255)).toString(16)).slice(-2) + ("00" + (~ ~(b * 255)).toString(16)).slice(-2);
                return (c);
            }

            // } // end of startGame()

            // window.addEventListener('resize', () => {
            //     let canvas = document.getElementById("canvas");
            //     canvas.width = window.innerWidth;
            //     canvas.height = window.innerHeight;
            //     startGame();
            // });
        }
    </script>
</body>

</html>